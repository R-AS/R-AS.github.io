---
title: '防抖与节流'
date: '2022-12-05'
thumbnail: 'javascript/index.png'
type: 'interview-javascript'
---
```toc
```
---

#### 防抖

- 作用：不管事件触发频率多高，一定在最新事件触发 n 秒后才执行（n 秒内又触发这个事件，重新计时）
- 应用场景：
    - 窗口大小变化，调整样式
    ```js
      window.addEventListener('resize', debounce(handleResize, 200));
    ```
    - 搜索框，输入后1000毫秒搜索
    ```js
    debounce(fetchSelectData, 300);
    ```
    - 表单验证，输入1000毫秒后验证
    ```js
    debounce(validator, 1000);
    ```
- 实现：

```js
function debounce(fn, time) {
  let timer = null

  return function(...args) {
    clearTimeout(timer)
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, time)
  }
}

// 让函数立即执行一次，再等后面事件触发后等待 n 秒执行
function debounce(fn, time, flag) {
  let time = null

  return function(...args) {
    clearTimeout(timer)
    if (flag && !timer) {
      fn.apply(this, args)
    }
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, time)
  }
}
```

---

#### 节流

- 作用：不管事件触发频率多高，只在单位时间内执行一次
- 实现：

```js
// 定时器实现
function throttle(fn, time) {
  let time = null

  return function(...args) {
    if (!timer) {
      timer = setTimeout(() => {
        timer = null
        fn.apply(this, args)
      }, time)
    }
  }
}

// 时间戳实现
function throttle(fn, time) {
  let pre = 0

  return function(...args) {
    if (Date.now() - pre > time) {
      pre = Date.now()
      fn.apply(this, args)
    }
  }
}

// 结合版
function throttle(fn, time) {
  let pre = 0
  let timer = null

  return function(...args) {
    if (Date.now() - pre > time) {
      clearTimeout(timer)
      timer = null
      pre = Date.now()
      fn.apply(this, args)
    } else if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, args)
      }, timer)
    }
  }
}
```
