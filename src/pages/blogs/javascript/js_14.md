---
title: '闭包'
date: '2022-06-09'
thumbnail: 'javascript/index.png'
type: 'javascript'
---

1. **闭包概念：** 函数执行后返回结果是一个内部函数，并被外部变量引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包。
2. **闭包原理：**
- 预编译阶段，如果发现内部函数使用了外部函数的变量，则会在内存中创建一个“闭包”对象并保存对应变量值。如果已存在“闭包”，则只需要增加对应属性值即可。
- 执行完后，函数执行上下文会被销毁，函数对“闭包”对象对引用也会被销毁，但其内部函数还持有该“闭包”的引用，所以内部函数可以继续使用”外部函数“中的变量。
3. 优点：
- 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用。
- 避免变量污染全局
- 把变量存在独立的作用域，作为私有成员存在
4. 缺点：
- 对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏
- 对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找是经过的作用域链长度。
- 可能获取到意外的值（captured value）
5. 应用场景：
```js
  // 应用场景一：典型应用是模块封装，在各模块规范出现之前，都是用这样的方式防止变量污染全局。
  var Yideng = (function() {
    // 这样声明为模块私有变量，外界无法直接访问
    var foo = 0

    function Yideng() {}
    Yideng.prototype.bar = function bar() {
      return foo
    }
    return Yideng
  }())
```
```js
  /**
   * 在循环中创建闭包，防止取到意外的值 
   * 如下代码，无论哪个元素触发事件，都会弹出 3。因为函数执行后引用的 i 是同一个，而 i 在循环结束后就是 3
   * 因为这个循环的终止条件是 i 不再 < 3，条件首次成立时 i 的值是 3，因此输出显示的是循环结束 i 的最终值
   **/
  for (var i = 0; i < 3; i++) {
    document.getElementById('id' + i).onfocus = function() {
      alert(i)
    }
  }
  // 可用闭包解决（为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代内部都会含有一个具有正确值的变量可以访问。）
  function makeCallback(num) {
    return function() {
      alert(num)
    }
  }
  for (var i = 0; i < 3; i++) {
    document.getElementById('id' + i).onfocus = makeCallback(i)
  }
```