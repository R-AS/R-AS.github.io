---
title: '防抖与节流'
date: '2022-06-08'
thumbnail: 'javascript/index.png'
type: 'javascript'
---
```toc
```
---
#### 防抖
- 原理：在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。
- 使用场景：防止多次提交按钮，只执行最后提交的一次；防止连续发送请求，只发送最后一次。
- 实现：
```js
  // 简易版实现
  function debounce(fn, wait) {
    let timer
    return function(...rest) {
      clearTimeout(timer)
      timer = setTimeout(() => {
        fn.apply(this, rest)
      }, wait)
    }
  }

  // 立即执行版实现（有时希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新执行）
  function debounce(fn, wait, immediate) {
    let timer
    return function(...rest) { // ...rest 得出结果是一个数组（多个参数），rest 是单项
      if (timer) clearTimeout(timer)
      if (immediate) {
        const callNow = !timer
        timer = setTimeout(() => {
          timer = null // n 秒后 timer 空，下一次调用 callNow true
        }, wait)
        if (callNow) {
          fn.apply(this, rest)
        }
      } else {
        timer = setTimeout(() => [
          fn.apply(this, ...rest)
        ], wait)
      }
    }
  }
```

---

#### 节流
- 原理：规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效。
- 使用场景：固定时间内只执行一次，防止超高频次触发位置变动；监控浏览器 resize;(拖拽，缩放)
- 实现：
```js
  // 定时器实现
  function throttle(fn, wait) {
    let timer
    return function(...rest) {
      if (!timer) {
        timer = setTimeout(() => {
          timer = null
          fn.apply(this, rest)
        }, wait)
      }
    }
  }

  // 时间戳实现
  function throttle(fn, wait) {
    let previous = 0
    return function(...rest) {
      let now = +new Date()
      if (now - previous > wait) {
        fn.apply(this, rest)
        previous = now
      }
    }
  }
```