{"componentChunkName":"component---src-templates-blog-post-jsx","path":"/blogs/typescript/ts_1/","result":{"data":{"markdownRemark":{"html":"<h3>{}, object, Object 有什么区别</h3>\n<p>这三种类型表示你的值是<strong>一个没有任何自定义属性</strong>的对象，只从 Object.prototype 继承了基本的方法:</p>\n<pre><code class=\"language-typescript\">let user: object = { name: 'Jelly' }\nuser.toString() // correct\nuser.name // error: Property 'name' does not exist on type 'object'\n</code></pre>\n<p>分析以下代码：</p>\n<pre><code class=\"language-typescript\">let title: {}\ntitle = {}  // correct\ntitle = []  // correct\ntitle = 123 // correct\n\nlet content: object\ncontent = {}  // correct\ncontent = []  // correct\ncontent = 123 // error: Type '123' is not assignable to type 'object'.\n</code></pre>\n<p><strong>如果一个变量的值是 object 类型，那么它可以是任何非原始类型值</strong>\n<strong>{}类型不仅包含非原始类型，还包含除 null | undefined 之外的其他原始类型</strong>\n(Object 与 {} 基本一致)\n原始类型:</p>\n<ul>\n<li>string</li>\n<li>boolean</li>\n<li>number</li>\n<li>bigint</li>\n<li>symbol</li>\n<li>null</li>\n<li>\n<h1>undefined</h1>\n<h3>type alias 与 interface 的差异</h3>\n</li>\n<li>同一个作用域中同名的 interface 会合并声明, 相反 type alias 则会报错</li>\n<li>type alias 的右值可以是任何类型, 包括原始类型和类型表达式</li>\n<li>\n<h1>interface 可以继承其他 shape 类型(非原始类型 object)</h1>\n<h3>泛型</h3>\n<p>观察以下代码：</p>\n<pre><code class=\"language-typescript\">type Arrayify = &#x3C;T>(data: T) => T[] // 1\ntype Arrayify&#x3C;T> = (data: T) => T[] // 2\n</code></pre>\n<p>1 和 2 实际上泛型覆盖的作用域不同(<strong>简单的说,泛型定义的位置决定了他涵盖的作用域</strong>)\n例如下面的例子就一目了然了</p>\n<pre><code class=\"language-typescript\">type Arrayify = {\n&#x3C;T>(data: T): T[]\ncustomProp: string\n}\ntype Arrayify&#x3C;T> = {\n(data: T): T[]\ncustomProp: T\n}\n</code></pre>\n</li>\n</ul>","frontmatter":{"title":"Typrscript 记录","date":"2020-01-10T00:00:00.000Z"},"excerpt":"{}, object, Object 有什么区别 这三种类型表示你的值是一个没有任何自定义属性的对象，只从 Object.prototype 继承了基本的方法: 分析以下代码： 如果一个变量的值是 object…"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/typescript/ts_1/"}}}